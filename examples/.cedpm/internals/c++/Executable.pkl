module CppExecutable
extends "@build-system/Executable.pkl"

import "@build-system/Target.pkl" as Target
import "@build-system/Instruction.pkl" as Instruction
import "@utils/string.pkl" as StringUtil
import "@utils/os.pkl" as OS

debug: Boolean = false;
compiler: String = read("env:CXX")
standard: String = read("env:CXXSTANDARDS").split(" ").last;
flags: String = read("env:CXXFLAGS")
modules: Listing<String>
libraries: Listing<String>
sources: Listing<String>

outputDir = "."
compiledModulePath = (modulePath: String) ->
		modulePath + ".o"
precompiledModulePath = (modulePath: String) ->
		modulePath + ".pcm"

function findModules(dir: String, pattern: String): Listing<String> =
	OS.cli("cppmodsort $(find "+ dir +" -type f -name \""+ pattern +"\")").split("\n").toListing()

// TODO: change this according compilers
function target(): Target = new {
	local compile_prefix = compiler
		+ " "
		+ flags
		+ if (debug) " -g" else ""
		+ " -std=" + standard;
	name = "hello"
	type = "Executable"
	instructions {
		... modules.toList().map((file) ->
			new Instruction {
				inputs { file }
				result = precompiledModulePath.apply(file)
				command = compile_prefix + " --prebuilt-module-path=. --precompile " + file + " -o " + result
			}
		).toListing();

		... modules.toList().map((file) ->
			new Instruction {
				inputs { precompiledModulePath.apply(file) }
				result = compiledModulePath.apply(file)
				command = compile_prefix + " --prebuilt-module-path=. -c " + file + ".pcm -o " + file + ".o "
			}
		).toListing();

		new Instruction {
			inputs {
				... modules.toList().map((file) -> compiledModulePath.apply(precompiledModulePath.apply(file))).toListing()
			}
			result = name
			command = compile_prefix + " " + StringUtil.join(inputs) + " -o " + name
		}
	}
}
